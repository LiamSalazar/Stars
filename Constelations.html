<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Constelaciones Zodiacales</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(ellipse at center, #000015 0%, #000000 100%);
      font-family: Arial, sans-serif;
      color: white;
    }
    canvas {
      display: block;
    }
    .label {
      position: absolute;
      color: #ffffff;
      font-size: 16px;
      font-weight: bold;
      text-shadow: 0 0 12px rgba(0, 204, 255, 0.9), 0 0 8px rgba(255,255,255,0.9);
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, stars = [], lines = [], labels = [], group;
    let mouseX = 0, mouseY = 0, targetX = 0, targetY = 0;

    const spread = 100;
    const starGroups = {
      Gemini: [ [-spread, 0, 0], [-spread + 10, 20, 0], [-spread + 20, 30, 0], [-spread + 30, 20, 0], [-spread + 40, 10, 0], [-spread + 50, 0, 0] ],
      Cancer: [ [-spread + 20, -60, 0], [-spread + 30, -45, 0], [-spread + 40, -60, 0], [-spread + 50, -75, 0], [-spread + 40, -90, 0], [-spread + 30, -75, 0] ],
      Libra: [ [0, 0, 0], [15, 20, 0], [30, 0, 0], [15, -20, 0], [0, -10, 0] ],
      Leo: [ [spread, 40, 0], [spread + 10, 50, 0], [spread + 20, 40, 0], [spread + 30, 30, 0], [spread + 40, 20, 0] ],
      UrsaMajor: [ [spread, -40, 0], [spread + 10, -30, 0], [spread + 20, -20, 0], [spread + 30, -10, 0], [spread + 40, 0, 0], [spread + 50, 10, 0], [spread + 60, 0, 0] ]
    };

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 150;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const starMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        emissive: 0x99ccff,
        emissiveIntensity: 2,
        transparent: true,
        opacity: 0.95
      });
      const starGeometry = new THREE.SphereGeometry(2.5, 32, 32);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x88ccff });

      group = new THREE.Group();

      Object.entries(starGroups).forEach(([name, coords]) => {
        let centroid = new THREE.Vector3();
        coords.forEach((coord, i) => {
          const star = new THREE.Mesh(starGeometry, starMaterial);
          star.position.set(...coord);
          centroid.add(star.position);
          group.add(star);
          stars.push(star);

          if (i > 0) {
            const points = [
              new THREE.Vector3(...coords[i - 1]),
              new THREE.Vector3(...coord)
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, lineMaterial);
            group.add(line);
            lines.push(line);
          }
        });

        centroid.divideScalar(coords.length);
        const label = document.createElement('div');
        label.className = 'label';
        label.innerText = name;
        document.body.appendChild(label);
        labels.push({ element: label, position: centroid });
      });

      scene.add(group);
      window.addEventListener('resize', onWindowResize, false);
      document.addEventListener('mousemove', onMouseMove, false);

      animate();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
      mouseX = (event.clientX - window.innerWidth / 2) / 100;
      mouseY = (event.clientY - window.innerHeight / 2) / 100;
    }

    function animate() {
      requestAnimationFrame(animate);

      targetX += (mouseX - targetX) * 0.05;
      targetY += (mouseY - targetY) * 0.05;
      group.rotation.y = targetX * 0.03;
      group.rotation.x = targetY * 0.03;

      renderer.render(scene, camera);

      labels.forEach(({ element, position }) => {
        const vector = position.clone().project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
        element.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
        element.style.opacity = 1;
      });
    }

    init();
  </script>
</body>
</html>
